<!DOCTYPE html>
<html>
	
	<head>
	
		<meta charset="utf-8">
		<title>MSF Water Quality Assessment</title>
	
	</head>
	
	<body>
		
		<div id="header">
			<h2>MSF Water Quality Assessment</h2>
			<p id="status">[OpenCV.js is loading, please wait...]</p>
			<br>
		</div>
		
		<div style="display: flex" id="main">
		
			<div style="flex: 0 0 15%" id="config">
				<div id="count">
					<p>count: <span id="countDisplay">0</span></p>
				</div>
			</div>
			
			<div style="flex: 1" id="images">
				
				<div id="imgSrc">
					<canvas id="canvasInput"></canvas>
					<br>
					<input type="file" id="fileInput" name="file"></input>
				</div>
				
				<div id="imgRes">
					<canvas id="canvasOutput"></canvas>
				</div>
				
			</div>
			
			<div style="flex: 1">
				<div id="imgResOverlay">
					<canvas id="canvasOverlayOutput"></canvas>
				</div>
			</div>
	
		</div>
		
		<script type="text/javascript">
			
			const w = 360;
			const h = 640;
			
			let inCanvas = document.getElementById("canvasInput");
			let outCanvas = document.getElementById("canvasOutput");
			let outCanvasOverlay = document.getElementById("canvasOverlayOutput");
			
			let inFile = document.getElementById("fileInput");
			inFile.addEventListener("change", (ev) => {
				let img = new Image();
				img.src = URL.createObjectURL(ev.target.files[0]);
				img.width = w;
				img.height = h;
				img.onload = function() {
					inCanvas.width = img.width;
					inCanvas.height = img.height;
					
					outCanvas.width = img.width;
					outCanvas.height = img.height;
					
					outCanvasOverlay.width = img.width;
					outCanvasOverlay.height = img.height;
					// inCanvas.width = w;
					// inCanvas.height = h;
					inCanvas.getContext("2d").drawImage(img, 0, 0, img.width, img.height);
					// inCanvas.getContext("2d").drawImage(img, 0, 0, w, h);
					processImage();
				}
			}, false);
			
			
			// image
			
			function processImage() {
				
				let src = cv.imread("canvasInput");
				
				let data = new cv.Mat((src.rows * src.cols), 3, cv.CV_32F);
				for (var y = 0; y < src.rows; y++) {
					for (var x = 0; x < src.cols; x++) {
						for (var z = 0; z < 3; z++) {
							data.floatPtr(y + (x * src.rows))[z] = src.ucharPtr(y,x)[z];
						}
					}
				}
				
				let k = 2;
				let labels = new cv.Mat();
				let criteria = new cv.TermCriteria(cv.TermCriteria_EPS + cv.TermCriteria_MAX_ITER, 10, 1.0);
				let centers = new cv.Mat();
				let attempts = 3;
				cv.kmeans(data, k, labels, criteria, attempts, cv.KMEANS_PP_CENTERS, centers);
				
				let count0 = 0;
				let count1 = 0;
				for (var y = 0; y < src.rows; y++) {
					for (var x = 0; x < src.cols; x++) {
						let cluster_idx = labels.intAt((y + (x * src.rows)), 0);
						if (cluster_idx == 0) count0++;
						if (cluster_idx == 1) count1++;
					}
				}
				
				let idxBias = (count0 > count1) ? 0 : 1;
				let dual = new cv.Mat(src.size(), cv.CV_8UC1);
				for (var y = 0; y < src.rows; y++) {
					for (var x = 0; x < src.cols; x++) {
						let cluster_idx = (idxBias - labels.intAt((y + (x * src.rows)), 0));
						dual.ucharPtr(y, x)[0] = (cluster_idx * 255);
					}
				}
				
				let grey = new cv.Mat(dual.size(), cv.CV_8UC1);
				// cv.cvtColor(dual, grey, cv.COLOR_RGBA2GRAY, 0);
				cv.threshold(dual, grey, 0, 255, (cv.THRESH_BINARY + cv.THRESH_OTSU));
				
				let kernelErode = cv.Mat.ones(5, 5, cv.CV_8UC1);
				let anchor = new cv.Point(-1, -1);
				cv.erode(grey, grey, kernelErode, anchor, 1, cv.BORDER_CONSTANT, cv.morphologyDefaultBorderValue());
				
				let kernelClose = cv.Mat.ones(3, 3, cv.CV_8UC1);
				cv.morphologyEx(grey, grey, cv.MORPH_CLOSE, kernelClose);
				
				let contours = new cv.MatVector();
				let hierarchy = new cv.Mat();
				cv.findContours(grey, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);
				
				let overlay = new cv.Mat();
				src.copyTo(overlay);
				for (var i = 0; i < contours.size(); i++) {
					let boundRect = cv.boundingRect(contours.get(i));
					if (boundRect.width <= 50) {
						cv.drawContours(overlay, contours, i, new cv.Scalar(0, 255, 0, 255), 2);
					}
				}
				// cv.drawContours(overlay, contours, -1, new cv.Scalar(0, 255, 0, 255), 2);
				
				cv.imshow("canvasOutput", grey);
				cv.imshow("canvasOverlayOutput", overlay);
				
				document.getElementById("countDisplay").innerHTML = contours.size();
				
				src.delete();
				data.delete();
				labels.delete();
				centers.delete();
				dual.delete();
				grey.delete();
				kernelClose.delete();
				kernelErode.delete();
				contours.delete();
				hierarchy.delete();
				overlay.delete();

			};
		
			const onOpenCvReady = () => {
				// cv.onRuntimeInitialized = () => {
				// 	try {
				// 		processImage();
				// 	} catch(err) {
				// 		console.log(err);
				// 		document.getElementById("status").innerHTML = "[OpenCV.js is ready.]";
				// 	}
				// }
				document.getElementById("status").innerHTML = "[OpenCV.js is ready.]";
			}
			
			document.addEventListener("keypress", (ev) => {
				if (ev.key === "Enter") processImage()
			});
		
		</script>
		
		<script async src="opencv.js" onload="onOpenCvReady()" type="text/javascript"></script>
	
	</body>
</html>

