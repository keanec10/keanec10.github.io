<html>

	<head>

		<style>
			.bar {
				fill: steelblue;
			}
		</style>
	
	</head>

	<body>

		<div id="userScreen" style="display:inline;">
			<P>Enter a github user:</P>
			<input type="text" id="user">
			<br>
			<br>
			<button onclick="checkUser()">Next</button>
		</div>

		<div id="phraseScreen" style="display:none;">
			<p>Enter a phrase:</p>
			<input type="text" id="phrase">
			<br>
			<br>
			<button onclick="getPhraseData()">Get data!</button>
		</div>
		
		<div id="dataScreen" style="display:none;">
			<p id="data"></p>
		</div>
		
		<div id="loadingScreen" style="display:none;">
			<p>Loading...</p>
		</div>
		
		<svg></svg>
		
		<script src="https://d3js.org/d3.v4.js"></script>
		
		<script type="text/javascript">
		
			var phrases = [{phrase: "hi", count: 0}, {phrase:"boo", count: 10}];
			var phrasesMax = 100;
			
			var pad = 0.4;
			var margin = 60;
			var width = 1000;
			var height = 600;
			
			var svg = d3.select("body").append("svg").attr("width", width).attr("height", height).attr("margin", margin).attr("pad", pad);
			
			var x_scale = d3.scaleLinear().domain([0, phrasesMax]).range([margin, width-margin]);
			
			var x_axis = d3.axisBottom().scale(x_scale);
			
			svg.append('g').attr("transform", "translate(" + 0 + "," + (height-margin) + ")").attr("id", "xaxis").call(x_axis);
			
			var y_scale = d3.scaleBand().domain(phrases.map(function(d) { return d.phrase })).range([0, height]).padding(pad);
			
			var y_axis = d3.axisLeft().scale(y_scale);
			
			svg.append('g').attr("transform", "translate(" + margin + "," + (-margin) + ")").attr("id", "yaxis").call(y_axis);
			
			svg.selectAll(".bar").data(phrases).enter().append("rect").attr("class", "bar")
				.attr("x", margin).attr("y", function(d) { return (y_scale(d.phrase) - margin); })
				.attr("width", function(d) { return (x_scale(d.count) - margin) }).attr("height", (height/(2*phrases.length)));

			function updateUI() {
				
				x_scale.domain([0, phrasesMax]);
				y_scale.domain(phrases.map(function(d) { return d.phrase }));
				
				svg.select("#xaxis").transition().duration(1000).call(x_axis);
				svg.select("#yaxis").transition().duration(1000).call(y_axis);
				
				svg.selectAll(".bar").data(phrases).transition().duration(1000)
				.attr("y", function(d) { return (y_scale(d.phrase) - margin); })
				.attr("height", (height/(2*phrases.length)));
				
				svg.selectAll(".bar").data(phrases).enter().append("rect").attr("class", "bar").transition().duration(1000)
				.attr("x", margin).attr("y", function(d) { return (y_scale(d.phrase) - margin); })
				.attr("width", function(d) { return (x_scale(d.count) - margin) }).attr("height", (height/(2*phrases.length)));
				
			}

			var userChecked = false;
			var user;
			var repos;
			
			function checkUser() {
				
				document.getElementById("userScreen").style.display = "none";
				document.getElementById("loadingScreen").style.display = "inline";
				user = document.getElementById("user").value;
				var userUrl = ("https://api.github.com/users/" + user + "/repos");
				var userRequest = new XMLHttpRequest();
				userRequest.onload = verifyUser;
				userRequest.open("get", userUrl, true);
				userRequest.send();
				
				function verifyUser() {
					
					if (JSON.parse(this.responseText).message == "Not Found") {
						alert("No such Github user exists! Try again");
						document.getElementById("data").innerHTML = "";
						return;
					}
					
					repos = JSON.parse(this.responseText);
					document.getElementById("loadingScreen").style.display = "none";
					document.getElementById("phraseScreen").style.display = "inline";
					userChecked = true;
					
				}
				
			}
			
			function getPhraseData() {
				
				var filesScanned = 0;
				var numOfFiles = 0;
				
				document.getElementById("loadingScreen").style.display = "inline";
				document.getElementById("phraseScreen").style.display = "none";
				var inputPhrase = document.getElementById("phrase").value;
				if (inputPhrase == "") {
					alert("Can't search for an empty phrase! Try again");
					document.getElementById("data").innerHTML = "";
					return;
				}
				
				currentPhraseObj = {
					phrase : inputPhrase,
					count : 0
				};
				
				for (var i = 0; i < repos.length; i++) {
					var repoUrl = repos[i].contents_url.replace("{+path}", "");
					var repoRequest = new XMLHttpRequest();
					repoRequest.onload = scanContents;
					repoRequest.open("get", repoUrl, true);
					repoRequest.send();
				}
				
				function scanContents() {
					
					var contents = JSON.parse(this.responseText);
					numOfFiles += contents.length;
					for (var i = 0; i < contents.length; i++) {
						var fileUrl = contents[i].download_url;
						var fileRequest = new XMLHttpRequest();
						fileRequest.onload = scanFile;
						fileRequest.open("get", fileUrl, true);
						fileRequest.send();
					}
					
					function scanFile() {
						
						currentPhraseObj.count += occurencesOfPatternInText(currentPhraseObj.phrase, this.responseText);
						filesScanned++;
						if ((filesScanned == numOfFiles) && (numOfFiles > 1)) {
							var alreadyThere = false;
							for (var i = 0; i < phrases.length; i++) {
								if (phrases[i].phrase == currentPhraseObj.phrase) {
									alreadyThere = true;
								}
							}
							if (!alreadyThere) {
								phrases.push(currentPhraseObj);
							}
							if (currentPhraseObj.count > phrasesMax) {
								phrasesMax = currentPhraseObj.count;
							}
							document.getElementById("loadingScreen").style.display = "none";
							document.getElementById("dataScreen").style.display = "inline";
							document.getElementById("phraseScreen").style.display = "inline";
							document.getElementById("data").innerHTML = "Number of occurences of '" + currentPhraseObj.phrase + "' in " + user + "'s files: " + currentPhraseObj.count;
							updateUI();
						} else if (filesScanned == numOfFiles) {
							console.log("boo");
						}
						
					}
					
				}
				
			}
			
			function occurencesOfPatternInText(pattern, text) {
				
				var count = 0;
				while (text.search(pattern) != -1) {
					text = text.slice(text.search(pattern) + pattern.length);
					count++;
				}
				return count;
				
			}
			
			
		</script>

	</body>

</html>